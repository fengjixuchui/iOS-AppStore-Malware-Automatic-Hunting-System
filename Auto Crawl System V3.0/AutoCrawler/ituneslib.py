#!/usr/bin/env python
# coding:utf-8

__version__ = '1.0.0'
__author__ = 'phuslu@hotmail.com'

import sys
import os
import traceback
import re
import time
import ctypes
import random
import logging
import collections
import string
import plistlib
import urllib
import base64
import pprint
import json
import requests
import httplib
import _winreg as winreg


def get_itunes_proxy_dll():
    #print os.path.join(os.getcwd(), 'iTunesProxy\\Debug\\iTunesProxy.dll')
    return os.path.join(os.getcwd(), 'iTunesProxy\\Debug\\iTunesProxy.dll')


def get_user_agent():
    #return 'AppStore/3.0 iOS/10.0.1 model/iPhone6,2 build/12B466 (6; dt:90)'
    return 'AppStore/2.0 iOS/8.1.3 model/iPhone6,2 build/12B466 (6; dt:90)'
    #return 'AppStore/3.0 iOS/9.0.1 model/iPhone6,2 build/12B466 (6; dt:90)'
    #return 'AppStore/3.0 iOS/11.0.3 model/iPhone10,1 hwp/t8015 build/15A432 (6; dt:157)'
    #return 'AppStore/3.0 iOS/8.1.3 model/iPhone9,1 hwp/t8010 build/15A372 (6; dt:137)'
    # return 'MacAppStore/2.2 (Macintosh; OS X 10.12.4; 16E195) AppleWebKit/2603.1.30.0.34'
    # return 'iTunes/11.2.2 (Windows; Microsoft Windows 7 Enterprise Edition Service Pack 1 (Build 7601)) AppleWebKit/537.60.15'


def get_tz():
    return '28800'


def get_store_front(region='us'):
    if region == 'us':
        return '143441-1,17'
    elif region == 'cn':
        return '143465-2,17'
    else:
        raise ValueError('Unknow region(%r)' % region)


def get_sign_sap_setup_cert_url():
    return 'https://init.itunes.apple.com/WebObjects/MZInit.woa/wa/signSapSetupCert'


def get_sign_sap_setup_url():
    return 'https://play.itunes.apple.com/WebObjects/MZPlay.woa/wa/signSapSetup'


def get_bag_url(dsid):
    return 'https://init.itunes.apple.com/bag.xml?ix=5&dsid=%(dsid)s&ign-bsn=2' % dict(dsid=dsid)


def get_authenticate_url(pod=3):
    return 'https://p%d-buy.itunes.apple.com/WebObjects/MZFinance.woa/wa/authenticate' % pod


def get_getall_url():
    return 'https://upp.itunes.apple.com/WebObjects/MZBookkeeper.woa/wa/getAll'


def get_register_url(pod=3):
    return 'https://p%d-buy.itunes.apple.com/WebObjects/MZFinance.woa/wa/registerSuccess' % pod


def get_userratecontent_url(app_id, stars):
    return 'https://userpub.itunes.apple.com/WebObjects/MZUserPublishing.woa/wa/userRateContent?displayable-kind=11&id=%(app_id)s&rating=%(stars)s' % dict(app_id=app_id, stars=stars)


def get_writeuserreview_url(app_id):
    return 'https://userpub.itunes.apple.com/WebObjects/MZUserPublishing.woa/wa/writeUserReview?cc=cn&displayable-kind=11&id=%(app_id)s&l=en&dataOnly=true' % dict(app_id=app_id)


def get_saveuserreview_url():
    return 'https://userpub.itunes.apple.com/WebObjects/MZUserPublishing.woa/wa/saveUserReview?displayable-kind=11&dataOnly=true'


def get_search_url(term):
    return 'https://search.itunes.apple.com/WebObjects/MZStore.woa/wa/search?submit=edit&term=%s&limit=200' % urllib.quote(term.encode('utf8'))


def get_authorization_url(pod=2):
    return "https://p%d-buy.itunes.apple.com/WebObjects/MZFinance.woa/wa/authorizeMachine" % pod


def get_fake_computer_name():
    name = ''
    for i in xrange(10):
        name += string.uppercase[random.randint(0, 25)]
    return name


def change_itunes_guid_by_cpuinfo():
    """
    Itunes 其中 guid 分为 7 个段，每一个段是由相关pc信息计算后的前四个字节转为字符串。
    第一段：网卡地址
    第二段：C盘序列号
    第三段：ProductId
    第四段：CPU 信息
    第五段：主板信息
    第六段：计算机名
    第七段：Profile尾部字段
    这个函数通过修改 CPU 标识符实现部分修改 iTunes GUID
    """
    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, 'HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0', 0, winreg.KEY_ALL_ACCESS)
    cpuinfo, _ = winreg.QueryValueEx(key, 'ProcessorNameString')
    new_cpuinfo = cpuinfo.split('@')[0] + ' @ %d.%dGHz' % (random.randint(1, 9), random.randint(1, 2**31))
    winreg.SetValueEx(key, 'ProcessorNameString', 0, winreg.REG_SZ, new_cpuinfo)
    winreg.CloseKey(key)


class iTunesSession(object):
    """a iTunes Session"""
    def __init__(self, apple_id, password, region='us'):
        self.apple_id = apple_id
        self.password = password
        self.region = region
        self.itunes_proxy = ctypes.cdll.LoadLibrary(get_itunes_proxy_dll())
        assert self.itunes_proxy.InitFunctions()
        assert self.itunes_proxy.InitKeyBagID()
        assert self.itunes_proxy.InitSessionID()
        self.guid = self._get_itunes_guid()
        print self.guid
        self.machine_name = get_fake_computer_name()
        self.useragent = get_user_agent()
        self.store_front = get_store_front(region)
        self.tz = get_tz()
        self.pod = 18
        self.xtoken = ''
        self.dsid = ''
        self.session = requests.Session()
        self.session.verify = False

    def _get_itunes_guid(self):
        data = ctypes.create_string_buffer('', size=2048)
        size = self.itunes_proxy.GetGUID(data)
        return data[:size]

    def sign_in(self):
        apple_sign_sap_setup_cert_url = get_sign_sap_setup_cert_url()
        apple_sign_sap_setup_url = get_sign_sap_setup_url()
        apple_authenticate_url = get_authenticate_url(self.pod)

        logging.info('GET %r', apple_sign_sap_setup_cert_url)
        resp = self.session.get(apple_sign_sap_setup_cert_url, headers={
            'User-Agent': self.useragent,
            'X-Apple-Tz': self.tz,
            'X-Apple-Store-Front': self.store_front,
            'Accept-Encoding': 'gzip',
        })
        resp.raise_for_status()
        #raw_input()

        pl = plistlib.readPlistFromString(resp.text)
        cert_data = pl['sign-sap-setup-cert'].data
        logging.info('GET %r return len(cert_data)=%r', apple_sign_sap_setup_cert_url, len(cert_data))

        new_cert_data = ctypes.create_string_buffer('', size=2048)
        size = self.itunes_proxy.ExchangeCertificate(cert_data, len(cert_data), new_cert_data, 2048)
        new_cert_data = new_cert_data[:size]
        logging.info('ExchangeCertificate cert_data return len(new_cert_data)=%r', len(new_cert_data))

        logging.info('POST %r', apple_sign_sap_setup_url)
        pl = {
            'sign-sap-setup-buffer': plistlib.Data(new_cert_data),
        }
        resp = self.session.post(apple_sign_sap_setup_url, data=plistlib.writePlistToString(pl), headers={
            'User-Agent': self.useragent,
            'X-Apple-Tz': self.tz,
            'X-Apple-Store-Front': self.store_front,
            'Content-Type': 'application/x-apple-plist',
            'Accept-Encoding': 'gzip',
        })
        resp.raise_for_status()

        pl = plistlib.readPlistFromString(resp.text)
        sign_sap_setup_buffer = pl['sign-sap-setup-buffer'].data
        logging.info('POST %r return len(sign_sap_setup_buffer)=%r', apple_sign_sap_setup_url, len(sign_sap_setup_buffer))

        new_cert_data = ctypes.create_string_buffer('', size=2048)
        size = self.itunes_proxy.ExchangeCertificate(sign_sap_setup_buffer, len(sign_sap_setup_buffer), new_cert_data, 2048)
        new_cert_data = new_cert_data[:size]
        logging.info('ExchangeCertificate sign_sap_setup_buffer return len(new_cert_data)=%r', len(new_cert_data))

        pl = {
            'appleId': self.apple_id,
            'attempt': 0,
            'createSession': 'true',
            'guid': self.guid,
            'machineName': self.machine_name,
            'password': self.password,
            'rmp': '0',
            'why': 'signIn',
        }
        body = plistlib.writePlistToString(pl)
        body_signature = ctypes.create_string_buffer('', size=2048)
        size = self.itunes_proxy.ActionSignature(body, len(body), body_signature, 2048)
        body_signature = base64.b64encode(body_signature[:size])
        logging.info('ActionSignature body return body_signature=%r size=%s', body_signature, size)

        logging.info('POST %r', apple_authenticate_url)
        resp = self.session.post(apple_authenticate_url, data=body, headers={
            'User-Agent': self.useragent,
            'X-Apple-Tz': self.tz,
            'X-Apple-Store-Front': self.store_front,
            'X-Apple-ActionSignature': body_signature,
            'Content-Type': 'application/x-apple-plist',
            'Accept-Encoding': 'gzip',
        })
        try:
            resp.raise_for_status()
        except requests.exceptions.HTTPError as e:
            errmsg = str(e)
            print errmsg
            if '403 Client Error' in errmsg:
                m = re.search(r'://p(\d+)\-', errmsg)
                if m:
                    self.pod = int(m.group(1))
                    logging.info('SWITCH to POD=%d', self.pod)
                    assert self.itunes_proxy.InitKeyBagID()
                    assert self.itunes_proxy.InitSessionID()
                    return self.sign_in()
            raise

        pl = plistlib.readPlistFromString(resp.text.encode('utf8'))
        pprint.pprint(pl)
        account_info = pl['accountInfo']
        account_name = '%s %s' % (account_info['address']['firstName'], account_info['address']['lastName'])
        xtoken = pl['passwordToken']
        dsid = pl['dsPersonId']
        logging.info('POST %r return account_name=%s dsid=%r xtoken=%r', apple_authenticate_url, account_name, dsid, xtoken)

        self.xtoken = xtoken
        self.dsid = dsid

    def pc_authorization(self):
        apple_authenticate_url = get_authenticate_url(self.pod)
        apple_authorization_url = get_authorization_url(self.pod)
        pl = {
            'appleId': self.apple_id,
            'attempt': 1,
            'dsid': self.dsid,
            'guid': self.guid,
            'machineName': self.machine_name,
            'password': self.password,
            'kc': 1,
            'why': 'machineAuthorize'
        }
        body = plistlib.writePlistToString(pl)
        body_signature = ctypes.create_string_buffer('', size=2048)
        size = self.itunes_proxy.ActionSignature(body, len(body), body_signature, 2048)
        body_signature = base64.b64encode(body_signature[:size])
        logging.info('ActionSignature body return body_signature=%r size=%s', body_signature, size)

        logging.info('POST %r', apple_authenticate_url)
        resp = self.session.post(apple_authenticate_url, data=body, headers={
            'User-Agent': self.useragent,
            'X-Apple-Tz': self.tz,
            'X-Apple-Store-Front': self.store_front,
            'X-Apple-ActionSignature': body_signature,
            'Content-Type': 'application/x-apple-plist',
            'Accept-Encoding': 'gzip',
        })
        try:
            resp.raise_for_status()
        except:
            pass

        pl = {
            'guid': self.guid,
            'machineName': self.machine_name,
            'needDiv': 0
        }
        headers = {
            'User-Agent': self.useragent,
            'X-Apple-Tz': self.tz,
            'X-Apple-Store-Front': self.store_front,
            'X-Token': self.xtoken,
            'X-Dsid': self.dsid,
            'Content-Type': 'application/x-apple-plist',
            'Accept-Encoding': 'gzip',
        }
        kbsync_data = ctypes.create_string_buffer('', size=2048)
        size = self.itunes_proxy.GetKBSync(ctypes.c_ulonglong(int(self.dsid)), kbsync_data, 2048)
        kbsync_data = base64.b64encode(kbsync_data[:size])
        logging.info('GetKBSync body return kbsync_data=%r size=%s', kbsync_data, len(kbsync_data))
        pl['kbsync'] = plistlib.Data(base64.b64decode(kbsync_data))

        logging.info('POST %r', apple_authorization_url)
        resp = self.session.post(apple_authorization_url, data=plistlib.writePlistToString(pl), headers=headers)
        resp.raise_for_status()

    def buy_product(self, app_id):
        bag_url = get_bag_url(self.dsid)
        apple_getall_url = get_getall_url()
        apple_authenticate_url = get_authenticate_url(self.pod)

        headers = {
            'User-Agent': self.useragent,
            'X-Apple-Tz': self.tz,
            'X-Apple-Store-Front': self.store_front,
            'X-Token': self.xtoken,
            'Content-Type': 'application/x-apple-plist',
            'Accept-Encoding': 'gzip',
        }
        logging.info('GET %r', bag_url)
        resp = self.session.get(bag_url, headers=headers)
        resp.raise_for_status()

        pl = plistlib.readPlistFromString(resp.text.encode('utf8'))
        pl = plistlib.readPlistFromString(pl['bag'].data)
        buy_product_url = pl['buyProduct']
        song_download_done_url = pl['songDownloadDone']
        logging.info('GET %r return buy_product_url=%r song_download_done_url=%r', bag_url, buy_product_url, song_download_done_url)

        """
        apple_register_url = 'https://xp.apple.com/register'
        logging.info('GET %r', apple_register_url)
        self.session.get(apple_register_url, headers=headers).raise_for_status()
        """

        pl = {
            'domain': 'com.apple.upp'
        }
        headers = {
            'User-Agent': self.useragent,
            'Referer': 'https://search.itunes.apple.com/WebObjects/MZStore.woa/wa/search?src=hint&submit=edit&term=wechat',
            'X-Apple-Tz': self.tz,
            'X-Apple-Store-Front': self.store_front,
            'X-Dsid': self.dsid,
            'X-Token': self.xtoken,
            'Content-Type': 'application/x-apple-plist',
            'Accept-Encoding': 'gzip',
        }

        logging.info('POST %r', apple_getall_url)
        resp = self.session.post(apple_getall_url, data=plistlib.writePlistToString(pl), headers=headers)
        resp.raise_for_status()
        pl = plistlib.readPlistFromString(resp.text.encode('utf8'))
        logging.info('POST %r return %r', apple_getall_url, pl)

        apple_product_page_url = 'https://itunes.apple.com/%s/app/appname/id%s?mt=8' % (self.region, app_id)
        headers = {
            'User-Agent': self.useragent,
            'Referer': 'https://search.itunes.apple.com/WebObjects/MZStore.woa/wa/search?src=hint&submit=edit&term=wechat',
            'X-Apple-Tz': self.tz,
            'X-Apple-Store-Front': self.store_front,
            'Content-Type': 'application/x-apple-plist',
            'Accept-Encoding': 'gzip',
        }

        logging.info('GET %r', apple_product_page_url)
        resp = self.session.get(apple_product_page_url, headers=headers)
        resp.raise_for_status()
        m = re.search(r'"externalId":(\d+)', resp.text)
        if m is None:
            raise ValueError('GET %r return empty externalId' % apple_product_page_url)
        app_version_id = m.group(1)

        pl = {
            'appleId': self.apple_id,
            'attempt': 1,
            'guid': self.guid,
            'machineName': self.machine_name,
            'password': self.password,
            'kc': 1,
            'why': 'purchase'
        }
        body = plistlib.writePlistToString(pl)
        body_signature = ctypes.create_string_buffer('', size=2048)
        size = self.itunes_proxy.ActionSignature(body, len(body), body_signature, 2048)
        body_signature = base64.b64encode(body_signature[:size])
        logging.info('ActionSignature body return body_signature=%r size=%s', body_signature, size)

        logging.info('POST %r', apple_authenticate_url)
        resp = self.session.post(apple_authenticate_url, data=body, headers={
            'User-Agent': self.useragent,
            'X-Apple-Tz': self.tz,
            'X-Apple-Store-Front': self.store_front,
            'X-Apple-ActionSignature': body_signature,
            'Content-Type': 'application/x-apple-plist',
            'Accept-Encoding': 'gzip',
        })
        resp.raise_for_status()

        pl = plistlib.readPlistFromString(resp.text.encode('utf8'))
        account_info = pl['accountInfo']
        account_name = '%s %s' % (account_info['address']['firstName'], account_info['address']['lastName'])
        xtoken = pl['passwordToken']
        dsid = pl['dsPersonId']
        logging.info('POST %r return account_name=%s dsid=%r xtoken=%r', apple_authenticate_url, account_name, dsid, xtoken)

        self.xtoken = xtoken
        self.dsid = dsid

        pl = {
            'salableAdamId': str(app_id),
            'appExtVrsId': str(app_version_id),
            'guid': self.guid,
            'machineName': self.machine_name,
            'needDiv': '1',
            'mtApp': 'com.apple.iTunes',
            'mtClientId': '3z4Ci7I8z4Yaz5Dez9lsz1Nl2qkA1B',
            'mtEventTime': str(int(time.time() * 1000)),
            'mtPageId': '6940a41d-0cde-48ca-b4b0-83a8e94f59ee',
            'mtPageType': 'Search',
            'mtPrevPage': 'Genre_29099',
            'mtRequestId':'3z4Ci7I8z4Yaz5Dez9lsz1Nl2qkA1BzJ83V6DURzUKP',
            'mtTopic': 'xp_its_main',
            'pg': 'default',
            'price': '0',
            'pricingParameters': 'STDQ',
            'productType': 'C',
        }
        headers = {
            'User-Agent': self.useragent,
            'Referer': 'https://search.itunes.apple.com/WebObjects/MZStore.woa/wa/search?src=hint&submit=edit&term=wechat',
            'X-Apple-Tz': self.tz,
            'X-Apple-Store-Front': self.store_front,
            'X-Token': self.xtoken,
            'X-Dsid': self.dsid,
            'Content-Type': 'application/x-apple-plist',
            'Accept-Encoding': 'gzip',
        }

        kbsync_data = ctypes.create_string_buffer('', size=2048)
        size = self.itunes_proxy.GetKBSync(ctypes.c_ulonglong(int(self.dsid)), kbsync_data, 2048)
        kbsync_data =  base64.b64encode(kbsync_data[:size])
        logging.info('GetKBSync body return kbsync_data=%r size=%s', kbsync_data, len(kbsync_data))
        pl['kbsync'] = plistlib.Data(base64.b64decode(kbsync_data))

        logging.info('POST %r', buy_product_url)
        resp = self.session.post(buy_product_url, data=plistlib.writePlistToString(pl), headers=headers)
        resp.raise_for_status()

        text = ''.join(x.encode('hex') if ord(x) > 127 else x for x in resp.text.encode('utf8'))
        pl = plistlib.readPlistFromString(text)
        pprint.pprint(pl)
        song = pl['songList'][0]
        logging.info('POST %r return product_url=%r', buy_product_url, song['URL'])

        sinf_data = ""
        if pl['songList'][0]['sinfs'][0]['sinf']:
            sinf_data = pl['songList'][0]['sinfs'][0]['sinf'].data

        logging.info('Download APP start...')
        resp = requests.get(song['URL'], headers={'Cookie': 'downloadKey=%s' % song['downloadKey']})
        resp.raise_for_status()

        filename = '%s-%d.ipa' % (song['metadata']['softwareVersionBundleId'], song['songId'])
        filename = os.path.join(os.path.dirname(__file__), filename)
        with open(filename, 'wb') as fp:
            fp.write(resp.content)
        logging.info('Download APP to %r, filesize=%d', filename, os.path.getsize(filename))

        song_download_done_url += '&songId=%d&guid=%s&download-id=%s' % (song['songId'], self.guid, song['download-id'])
        logging.info('GET %r', song_download_done_url)
        headers = {
            'User-Agent': self.useragent,
            'Referer': 'https://search.itunes.apple.com/WebObjects/MZStore.woa/wa/search?src=hint&submit=edit&term=wechat',
            'X-Apple-Tz': self.tz,
            'X-Apple-Store-Front': self.store_front,
            'X-Token': self.xtoken,
            'X-Dsid': self.dsid,
            'Accept-Encoding': 'gzip',
        }
        resp = self.session.get(song_download_done_url, headers=headers)
        resp.raise_for_status()

        pl = plistlib.readPlistFromString(resp.text.encode('utf8'))
        logging.info('GET %r return %s', song_download_done_url, pl)

        # sign the ipa file using sinf
        import zipfile
        sinf_loc_path = ""
        sinf_ipa_path = ""
        zf = zipfile.ZipFile(filename, 'r')
        try:
            for ipa_file in zf.namelist():
                if ipa_file.startswith("Payload/") and ipa_file.endswith(".app/"):
                    sinf_fn = ipa_file.replace("Payload/", "").replace(".app/", "") + ".sinf"
                    sinf_loc_path = os.path.join(os.path.dirname(__file__), sinf_fn)
                    sinf_ipa_path = ipa_file + "SC_Info" + os.sep + sinf_fn
        finally:
            zf.close()

        if sinf_loc_path:
            with open(sinf_loc_path, 'wb') as f:
                f.write(sinf_data)
            f.close()

        zf = zipfile.ZipFile(filename, mode='a')
        try:
            zf.write(sinf_loc_path, arcname=sinf_ipa_path)
        finally:
            zf.close()

    def click_to_rate(self, app_id, stars):
        assert isinstance(stars, int) and 1 <= stars <= 5

        user_rate_content_url = get_userratecontent_url(app_id, stars)
        apple_getall_url = get_getall_url()

        pl = {
            'domain': 'com.apple.upp'
        }
        headers = {
            'User-Agent': self.useragent,
            'X-Apple-Tz': self.tz,
            'X-Apple-Store-Front': self.store_front,
            'X-Dsid': self.dsid,
            'X-Token': self.xtoken,
            'Content-Type': 'application/x-apple-plist',
            'Accept-Encoding': 'gzip',
        }

        logging.info('POST %r', apple_getall_url)
        resp = self.session.post(apple_getall_url, data=plistlib.writePlistToString(pl), headers=headers)
        resp.raise_for_status()
        pl = plistlib.readPlistFromString(resp.text)
        logging.info('POST %r return %r', apple_getall_url, pl)

        user_review_row_url = 'https://itunes.apple.com/WebObjects/MZStore.woa/wa/userReviewsRow?id=%s&displayable-kind=11&startIndex=0&endIndex=100&sort=1&appVersion=current' % app_id
        logging.info('GET %r', user_review_row_url)
        resp = self.session.get(user_review_row_url, headers=headers)
        resp.raise_for_status()

        pprint.pprint(json.loads(resp.text))

        headers = {
            'User-Agent': self.useragent,
            'X-Apple-Tz': self.tz,
            'X-Apple-Store-Front': self.store_front,
            'X-Dsid': self.dsid,
            'Content-Type': 'application/x-www-form-urlencoded',
            'Origin': 'https://itunes.apple.com',
            'Accept-Encoding': 'gzip, deflate',
            'Accept-Language': 'en-us, en;q=0.50',
        }
        data = 'desktopGuid=%s' % self.guid
        resp = self.session.post(user_rate_content_url, data=data, headers=headers)
        resp.raise_for_status()
        logging.info('POST %r with data=%r return %r', user_rate_content_url, data, resp.text)

    def write_a_review(self, app_id, title, body, stars):
        assert isinstance(stars, int) and 1 <= stars <= 5
        assert isinstance(title, basestring) and isinstance(body, basestring)

        write_user_review_url = get_writeuserreview_url(app_id)
        save_user_review_url = get_saveuserreview_url()
        apple_getall_url = get_getall_url()

        pl = {
            'domain': 'com.apple.upp'
        }
        headers = {
            'User-Agent': self.useragent,
            'X-Apple-Tz': self.tz,
            'X-Apple-Store-Front': self.store_front,
            'X-Dsid': self.dsid,
            'X-Token': self.xtoken,
            'Content-Type': 'application/x-www-form-urlencoded',
            'Accept-Encoding': 'gzip',
        }

        logging.info('POST %r', apple_getall_url)
        resp = self.session.post(apple_getall_url, data=plistlib.writePlistToString(pl), headers=headers)
        resp.raise_for_status()
        pl = plistlib.readPlistFromString(resp.text)
        logging.info('POST %r return %r', apple_getall_url, pl)

        form = collections.OrderedDict([
            ('id', app_id),
            ('displayable-kind', '11'),
            ('desktopGuid', self.guid),
        ])
        data = '&'.join('%s=%s' % (k, urllib.quote(str(v))) for k, v in form.items())

        logging.info('POST %r with data=%r', write_user_review_url, data)
        resp = self.session.post(write_user_review_url, data=data, headers=headers)
        resp.raise_for_status()
        info = json.loads(resp.text)
        pprint.pprint(info)

        form = collections.OrderedDict([
            ('id', app_id),
            ('displayable-kind', '11'),
            ('rating', stars),
            ('title', title),
            ('body', body),
            ('desktopGuid', self.guid),
        ])
        if info.get('showEditNickname'):
            form['nickname'] = self.apple_id.split('@')[0]
        data = '&'.join('%s=%s' % (k, urllib.quote(str(v))) for k, v in form.items())
        logging.info('POST %r with data=%r', save_user_review_url, data)
        resp = self.session.post(save_user_review_url, data=data, headers=headers)
        resp.raise_for_status()
        pprint.pprint(resp.text)

    def search(self, term):
        assert isinstance(term, basestring)

        search_url = get_search_url(term)
        apple_getall_url = get_getall_url()

        pl = {
            'domain': 'com.apple.upp'
        }
        headers = {
            'User-Agent': self.useragent,
            'X-Apple-Tz': self.tz,
            'X-Apple-Store-Front': self.store_front,
            'X-Dsid': self.dsid,
            'X-Token': self.xtoken,
            'Content-Type': 'application/x-www-form-urlencoded',
            'Accept-Encoding': 'gzip',
        }

        logging.info('POST %r', apple_getall_url)
        resp = self.session.post(apple_getall_url, data=plistlib.writePlistToString(pl), headers=headers)
        resp.raise_for_status()
        pl = plistlib.readPlistFromString(resp.text.encode('utf8'))
        logging.info('POST %r return %r', apple_getall_url, pl)

        logging.info('GET %r', search_url)
        resp = self.session.get(search_url, headers=headers)
        resp.raise_for_status()

        line = next(x for x in resp.text.splitlines() if 'its.serverData' in x)
        info = json.loads(line[line.index('{'):line.rindex('}')+1])
        app_ids= [x['id'] for x in info['pageData']['searchPageData']['bubbles'][0]['results']]
        app_infos = info['storePlatformData']["lockup-room"]['results']
        app_list = [app_infos[x] for x in app_ids if x in app_infos]
        return app_list


def tryOnce(userAccount, appInfo):

    logging.info('userAccount: [%r], appInfo:[%r]', userAccount, appInfo)
    change_itunes_guid_by_cpuinfo()
    (appID, passwd, region) = userAccount
    (app_id) = appInfo

    itunes_session = iTunesSession(appID, passwd, region=region)
    itunes_session.sign_in()
    song = itunes_session.buy_product(app_id) #, app_version_id='818741828')
    itunes_session.pc_authorization()


def main():
    logging.basicConfig(format='%(asctime)s [%(levelname)s] %(filename)s@%(lineno)s - %(funcName)s(): %(message)s', level=logging.INFO)
    logging.info("main enter:")
    userAccounts=[]
    userAccounts.append(("appleid","passwd","market")) # use your appleid, passwd, and market which your apple id belongs

    appInfo = ("905852173") #kua shi tong shang rong 1311355327 1224851236 899247664

    for userAccountItem in userAccounts:
        try:
            tryOnce(userAccountItem, appInfo)
        except Exception as e:
            traceback.print_exc()

    logging.info("main exit successfully!")


if __name__ == '__main__':
    main()
